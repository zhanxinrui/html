##函数表达式
- 定义函数的方式有两种，一是函数声明，二是函数表达式  
函数有其name属性，如:
functionName(arg0,arg1,arg2){
    //alert(functionName.name);//"funcitonName"
}
- 函数声明可以放在调用它的语句后面，它的特征就是函数声明提升（function declaration   hoisting）执行代码前会先读取函数声明  
- 函数表达式 最常用： var functionName = function(arg0,arg1,arg2){};  执行时需要 functionName()来执行
即创建一个匿名函数赋值给变量，它的name属性是空字符串  
- 不可以用if语句来选择定义函数声明，但可以函数表达式，这也和函数声明提升有关。
### 递归  
```javascript
function factorial(num){
    if(num<=1){
    return 1;
    }
}

    else{
    return num*factorial(num-1);
    }

var anotherFactorial = factorial;
factorial = null;
alert(anotherfactorial(4));//error
```
因为factorial指向了null，所以anotherFactorial使用factorial时递归时factorial就会指向空了，可以通过把递归调用的factorial改成arguments.callee(它会指向正在执行的函数)，因此仍然可以实现递归调用。或者使用有名函数表达式  
```javascript
var factorial = (function f(num){
    if(num<=1){
    return 1;
    }
    else{
    return num*f(num-1);
});//通过在声明函数外加一层括号来表示他是表达式

```
###闭包

闭包和匿名函数容易搞混，闭包就是 引用了自由变量的函数（在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量）。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。

####闭包与变量
```javascript
function f(){
    var result = new Array();
    for(var i = 0 ;i < 10; i++){
      result[i] = function(){
      return i;//result数组结果全是10，因为闭包引用的是i所以最后i是10，返回最后的i值
   }  
  }
}
通过修改 使内部使用的不是i,而是num,num的每个值不一样
function f(){
    var result = new Array();
    for(var i = 0 ;i < 10; i++){
      result[i] = function(num){//传进去的num值不同，
        return function(){//内嵌闭包纯粹是为了返回以个函数和上面的函数一致
          return num;
        }
      } (i);//（i）相当于执行这个匿名函数表达式，并传入参数i；函数声明不能这样用
    }
}
```P
//闭包只能取得包含函数中任何标量的最后一个值，闭包所保存的是整个变量对象而不是特殊的变量。所以每个函数引用的都是同一个变量i，都会返回10.
解决方法是：将闭包放入一个匿名函数中，闭包返回匿名函数的参数，同时每一次的i值作为匿名函数的参数传入，由于函数参数是按值传递的，所以最终可以返回不同的值。

####this对象
this即上下文 ，当调用嵌套函数时，对第二层的this是第一层函数去调用的，对于匿名函数的this指向的是全局对象。所以第二层的this是全局。
```javascript
var test1={
      a:1,
      b:2,
      }
}
因此为了能够在函数f中也可以调用上下文的this对象，可以使用通过如下方法解决：
如

var test1={
      a:1,
      fun1:function(){
             console.log(“fun1: “ +this);    //this为test1对象
             function f(){
                    console.log(“f: “ +this);   //this 为undefined 或者全局对象
             }
      b:2,
      fun1:function(){
            console.log(“fun1:this : “ +this);    //this为test1对象             var outer = this;
             function f(){        
      }
                    console.log(“f:this: “ +this);   //this 为undefined 或者全局对象
                    console.log(“f:outer: ” +outer);//outer则为外层的对象。 
             }
}
```
闭包可能会造成内存泄漏，因为函数引用外部对象，导致无法销毁元素，必须手动解除引用。

####模仿块级作用域
(function(){})(); 表达式可以这样，自执行 ，也叫作`私有定义域`

###私有变量
任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数外部访问这些变量。
可以使用特权方法，使得外部调用来访问，同时还可以隐藏那些不应该被直接修改的数据
如：
```javascript
function MyObject(){
    var privateVariable = 10;      
   function privateFunction(){   
        return false;
    }
   this.pubilcMethod = function(){
      privateVariable++;
      return privateFunction();
   }; 
}   
```
####静态私有变量
通过在私有作用域中定义私有变量或函数，也可以创建特权方法:  
```javascript
(function(){
    var name = "";
    Person = function(value){
    name = value;
  };  
  Person.prototype.getName = function(){
     return name;
  };
  Person.prototype.setName = function(value){name = value;}

})();
 
 var person1 = new Person("Nicholas");
 alert(person1.getName());//Nicholas
 person1.setName("Greg");
 alert(person1.getName());//Greg

  var person2 = new Person("Michael");
 alert(person1.getName());//Michael
 alert(person1.getName());//Michael
```
变量name就成了静态的，由所有实例共享的属性。

####模块模式
- 模块模式是为了只有一个实例的对象，创建私有变量和特权方法。js是以对象字面量的方式来创建单例对象。
这种模式在需要对单例进行某些初始化，同时有需要维护其私有变量时是非常有用的。
```javascript
var application = function(){//一个单例
    //私有变量和函数
    var components = new Array();
    //初始化
    components.push(new BaseComponent());
    //公共
    return {
    getComponentCount: function(){
     return components.length;
    },
    registerComponent: function(component){
       if(typeof component == "object"){
           components.push(component);
       }
    }
    } 

}
```
####增强的模块模式
就是创建的对象可以new成其他形式
