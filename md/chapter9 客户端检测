##客户端检测
浏览器提供商虽然在公共接口方面投入很多精力，但结果是每一种浏览器都各有各自的长处，也各有缺点，迄今为止客户端检测仍然是保守征集的话题，人们认为浏览器应该支持一组最常用的公共功能。 检测web客户端，最重要的是不到万不得已，不使用客户端检测，使用更通用的方法

###能力检测
最常用的检测形式，也称特性检测。能力检测的目标不是识别特定的浏览器，而是浏览器的能力。采用这种方法不必顾及特定的浏览器如何，只要确定浏览器支持特定的能力，就可以给出解决方案。
if(object.propertyInQuestion){
    //使用 object.propertyInQuestion  就是if是否存在这个属性，else。。。 
}
先检测达成目的的最常用特性，还必须测试实际要用到的特性，如document.all存在的浏览器不一定是IE，所以先检测时会 出错
#### 更可靠的能力检测
- 重要的是不要检测检测它是否按照适当的方式行事，而不是某个特性存在。如：
function isSortable(object){
    return !!object.sort;//有可能该对象有sort属性不一定有这个相应的函数
}
所以使用：  
function isSortable(object){
    return typeof object.sort == "function";
}

由于typeof的行为不标准，IE还可以举出许多例子来，返回的是object而不是function,还有ActiveX对象与其他对象的行为差异很大，直接把函数作为属性访问会导致错误。但使用typeof会返回unknow:
var xhr = new ActiveXObject("Microsoft.XMLHttp");
if(xhr.open){//error
    
}
所以使用下面这个函数更好
function isHostMethod(object,property)
{
var t = typeof object[property];
return t =='function' ||(!!(t=='object'&&object[property]))|| t=="unknow";
}

####能力检测不是浏览器检测、
- 不要试图用存在某些方法来确定它是哪一类的浏览器，因为浏览器之间相互模仿，而且浏览器  
迭代可能会删除某些方法

###怪癖检测（quirks detection）
- 与能力检测类似，quirks detection 的目标是识别浏览器的特殊行为，与能力检测  
不同。quirks detection是想有知道浏览器有什么缺陷。

###用户代理检测
- 通过检测用户代理字符串来确定实际使用的浏览器。在每一次HTTP请求中，用户dialing字符串是作为相应首部发送的而且该字符串可以通过JS的navigator.userAgent属性访问,在服务端，通过检测用户代理字符串来确定用户使用的浏览器是一种常用而且管委接受的做法，而在客户端，用户代理检测一般是万不得已采用的。
- 原因主要是浏览器的电子欺骗，修改用户代理字符串，欺骗服务器为了，把自己识别为mozilla，因为服务器会识别mozilla提供更好的服务。
####用户代理字符串检测技术
- 识别呈现引擎和最低限度的版本就可以了如：
if(ieVer>=6){}
-识别呈现引擎，确切的知道浏览器的名字和版本号不如确切的知道他使用的是什么呈现引擎，我们编写的脚本主要检测五大呈现引擎：IE,Gecko,WebKit ,KHTML,Opera;
为了不再全局作用域中添加多余的变量，我们将使用模块增强模式来封装检测代码。检测脚本代码结构如下：
 var client = fucntion(){
    //呈现引擎
    var engine = {
       ie:0,
       gecko:0,
       webkit:0,
       khtml :0,
       opera:0,
       ver:null
    };
    //在此检测呈现引擎，平台和设备
    return {
        engine:engine
    };
 }();

 //每个呈现引擎都对应一个属性的值，默认为0，如果检测到了哪个呈现引擎，那么就以浮点数值形式将该引擎的版本号写入相应的属性。而呈现引擎的完整版本，则被写入ver属性
 - 要正确的识别呈现引擎，关键是检测顺序要正确，由于用户代理字符串存在诸多不一致的地方  
 所以顺序不对，很可能导致检测结果不正确，所以第一步先识别Opera，因为它可能模仿其他浏览器。它不把自己识别为Opera，Opera有 window.opera对象 ：使用
 if(window.opera){
  engin.ver = window.opera.version();
  engine.opera = parseFloat(engine.ver);
 }
第二步检测的是webkit因为它的用户代理字符串中包含Gecko和KHTML，所以先检测它们，可能会得出错误的结论。不过webkit的用户代理字符串中的AppleWebkit是独一无二的，因此检测这个字  
符串最合适。：
var ua = navigator.userAgent;
if(window.opera){
    engine.ver = window.opera.version();
    engine.opera = parseFloat(engine.ver));
} else if(/AppleWebKit\/(\S+)/.test(ua)){
    engine.ver = RegExp["$1"];
    engine.webkit = parseFloat(engine.ver);
}
接下来要测试的引擎是KHTML，它也包含Gecko,因此 
else if(/KHTML\/(s+)/.test(ua)) || /Konqueror\/([^;]+)/.test(ua){
        engine.ver = RegExp["$1"];
    engine.khtml = parseFloat(engine.ver);
}
最后测试Gecko,
```javascript
else if(/rv:([^\ )]+) \ ) Gecko\/\d{8}/.test(ua)){
           engine.ver = RegExp["$1"];//RegExp.$1是RegExp的一个属性  ,指的是与正则表达式匹配的第一个子匹配(以括号为标志)字符串，
           engine.gecko = parseFloat(engine.ver);
}
```

- 2.是测试识别浏览器，由于浏览器和引擎密切相关，所以代码和识别引擎也是交织在一起，var browser = 
- 3.识别平台，windows,mac,unix      var system=
检测平台时使用navigator.platform比用户代理字符串方便
此外还有移动设备的支持，另外还有游戏系统，如任天堂Wii和Playstation3或者内置web浏览器，或者提供浏览器下载。

